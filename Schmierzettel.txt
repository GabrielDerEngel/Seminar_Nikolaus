C++ Grundlagen
--------------

Guten Morgen :)

Peter Loos

peter.loos@gmx.de

============================================================

a) C++ : Teilmenge: C, Java, Rust, Swift

b) Java, C# (Grundkenntnisse), Python

c) Wiederholung

d) Java (mehr als Grundkenntnisse)

e) Untertreibung 

Spagat: Basiswissen:  Kontrollstrukturen (if, while, for),  Funktionen, Parameter, 
                        (Prozedurale Programmierung)

============================================================

Montag Vormittag:  Grundlagen

Montag Nachmittag: Übung

Dialog-basiert

============================================================

Klasse:

Blueprint für Datenstrukturen:  Objekt oder Instanz

Attribute // Variablen der Klasse  // Member ==> m_
Methoden // Funktionen

C++: Wie ist eine Klasse samt Realisierung zu definieren? 2 Dateien.

a) Eine Header-Datei (Endung: .h)

b) Eine Quell-Datei (Source-File) (Endung: .cpp)

c) Programm // enthält main-Methode // Einsprungpunkt in das Programm


Datentypen:  int, float, double, (byte), ubyte_8 (C++ 17), char

i)  Elementaren Datentypen

ii) Benutzerdefinierten Datentypen: Klassen

// ==========================================

Syntaxfehler suchen ...........

Mehrere Möglichkeiten:

a) rechter Mausklick auf Dateiname: Compile (Übersetzen ==> Datei.OBJ)

b) Build Solution (Alle übersetzen + Linker: *.OBJ ==> .EXE)

Zusatz:

Das Ergebnis einer Übersetzung mehrerer Quelldateien (.CPP) 
kann eine Bibliothek (.LIB) sein.

Folge: Ein Verwender des Projekts bekommt Header-Files (.H)
und ein .LIB-File.

Aus dem .LIB-File kann keine vernünftige Quelldatei erzeugt werden.

Das KnowHow ist / bleibt geschützt.

// ==========================================

Zugriffsklassen // Sichtbarkeit: Was sehe ich "von außen"?
Sichtbarkeit:                    Was sehe ich "von innen"?


Idiom / Paradigma der OO:

Ein Objekt - genauer: seine Instanzvariablen, "sein Zustand" -
müssen zu jedem Zeitpunkt gültige Werte enthalten !

// ==========================================

Objekte mit Vorbelegungswerten erzeugen:

Dazu gibt es spezielle Methoden:  Konstruktor(en)

"sie konstruieren das Objekt"

Unterschied zu "normalen" Methoden:

i) Name ist festgelegt: Name der Klasse
ii) KEIN RÜCKGABETYP

In der Regel hat eine Klasse mehrere Konstruktoren.

Es gibt eine Technik für das "Wiederverwenden" von Konstruktoren-Quellcode:

"C++ Chaining of constructors"  // Verketten von Konstruktoren

 This feature is called "delegating constructors"

// ==============================================

m_day = nullptr;

Das geht nicht:

Weil Variablen elementaren Datentyps KEINE Objekte sind.

nullptr ginge nur bei Zeigern.

Das geht auch nicht bei Java / C# -- wenngleich es hier 
Unterschiede gibt (Boxing, Unboxing).

(( std::optional ))

"Bei Strings geht das":   std::string ist eine Klasse.

// ==============================================

Copy - Paste Programmierung:

a) Bei Änderungen muss ich n-fach ändern

b) Im dem besagten Stück Quellcode wurde ein Fehler entdeckt:

   Der muss n-fach geändert werden.

   Copy - Paste kopiert auch Fehler :(


// ==========================================

inline:

Es erfolgt kein CALL (ein CALL kostet im Vergleich mehr Laufzeit)

Sondern es wird im Maschinencode der Code des Rumpfes eingesetzt.

An einem Beispiel setDay: 14 Opcodes werden "inline" abgesetzt

inline ist ein "Hint" / Hinweis an den Übersetzer:

Tue das; Der Übersetzer entscheidet eigenständig.

// ==========================================

Code-Generator

Optimizer

Release-Mode

inline:  Performance 

Anderes Thema:

Vererbung  // virtual methods

'virtual' bedeutet: INDIREKTER Methodenaufruf

Performance:  Profiling

== regular expression
== std::string concatenation

Meine Meinung: IMHO

== Lesbarkeit: Sehr wichtig

== std::vector

   std::map   (Inhalt liegt sortiert vor)

   std::unordered_map  (Inhalt liegt NICHT sortiert vor)

   Suchen : Muss man tun. Wenn häufiger gesicht wird: Container wichtig.

== Call-by-XXX : "Wie häufig übergebe ich eine Kopie (unabsichtlich !!!)" // '&'

== STL ist sehr effizient und auch performant, wenn man sie richtig einsetzt.

    -- pro STL: Denken in "Bausteinen" // Rumpf der beteiligten "Funktion"

    -- contra STL: Das eine oder andere kann man (Beispiel: geschachtelte Schleifen)
             bequemer // effizienter programmieren.
             Möglicherweise fehleranfälliger IMHO.


== Kryptisches C:   Nebeneffekt    if (a > b && c < d++)  Was ist wenn a nicht größer b ist ???

                                    Short Circuit Evaluation

// ==========================================

Wozu gibt es Referenzen in C++?

Pointer sind "ähnlich" und können alles.

a) Pointer können zu Fehlern führen:  zb bei der Pointer-Arithmetik (zb ++ip)
   
b) Um für den indirekten Zugriff eine einfachere Schreibweise zu haben !!!
   -----------------------------------------------------------------------

   Man hat den * (Dereferenzierung) weggelassen !!!


C:     ++ *ip;     // unter der Annahme, dass ip gültig ist

C++:   ++ri;       // unter Beachtung, dass ri per Definition immer gültig ist


Bemerkung: C ist in C++ enthalten - das war eine Entwurfsentscheidung bei der Definition von C++.

// ==========================================

Parameterübergabe:

Prinzipiell: 

a) Value-based Languages

      C++: Per Default wird alles kopiert, per Wert weitergereicht

b) Reference-based Languages:

      C# , Java: Alles wird über eine Referenz erreicht (Ausnahme: elem. Datentypen)

      
In C++ können wir auch Parameter-Übergabe per Poiner / Referenz machen.


Besser : Call-by-Reference - (also keine C-Style Pointer).


Der Stack kann - im Gegensatz zu anderen Segmenten -
nur über ein Register angesprochen werden:

SP: Stack Pointer

Push:    ++ SP
Pop:     -- SP
Ret
Call

// ==========================================


// Überladen von Operatoren

Geht für nahezu alle Standard-C++-Operatoren.

Es sind nur Standard-C++-Operatoren erlaubt!

Und zu beachten ist:

Technisch wie das Erstellen einer Methoden / mit einem speziellen Namen.

Stelligkeit:  Es muss die Anzahl der Operanden identisch wie mit dem
vordefinierten Fall übereinstimmen.

Beispiel: == bedeutet 2 Operanden.

// ==========================================



Übung: Klasse Fraction

oder alternativ:

Klasse Time:

https://github.com/pelocpp/cpp_general_examples/blob/master/Examples/Time/Resources/Readme.md

// ==========================================
