C++ Grundlagen
--------------

Guten Morgen :)

Peter Loos

peter.loos@gmx.de

============================================================

Montag

============================================================

a) C++ : Teilmenge: C, Java, Rust, Swift

b) Java, C# (Grundkenntnisse), Python

c) Wiederholung

d) Java (mehr als Grundkenntnisse)

e) Untertreibung 

Spagat: Basiswissen:  Kontrollstrukturen (if, while, for),  Funktionen, Parameter, 
                        (Prozedurale Programmierung)

============================================================

Montag Vormittag:  Grundlagen

Montag Nachmittag: Übung

Dialog-basiert

============================================================

Klasse:

Blueprint für Datenstrukturen:  Objekt oder Instanz

Attribute // Variablen der Klasse  // Member ==> m_
Methoden // Funktionen

C++: Wie ist eine Klasse samt Realisierung zu definieren? 2 Dateien.

a) Eine Header-Datei (Endung: .h)

b) Eine Quell-Datei (Source-File) (Endung: .cpp)

c) Programm // enthält main-Methode // Einsprungpunkt in das Programm


Datentypen:  int, float, double, (byte), ubyte_8 (C++ 17), char

i)  Elementaren Datentypen

ii) Benutzerdefinierten Datentypen: Klassen

// ==========================================

Syntaxfehler suchen ...........

Mehrere Möglichkeiten:

a) rechter Mausklick auf Dateiname: Compile (Übersetzen ==> Datei.OBJ)

b) Build Solution (Alle übersetzen + Linker: *.OBJ ==> .EXE)

Zusatz:

Das Ergebnis einer Übersetzung mehrerer Quelldateien (.CPP) 
kann eine Bibliothek (.LIB) sein.

Folge: Ein Verwender des Projekts bekommt Header-Files (.H)
und ein .LIB-File.

Aus dem .LIB-File kann keine vernünftige Quelldatei erzeugt werden.

Das KnowHow ist / bleibt geschützt.

// ==========================================

Zugriffsklassen // Sichtbarkeit: Was sehe ich "von außen"?
Sichtbarkeit:                    Was sehe ich "von innen"?


Idiom / Paradigma der OO:

Ein Objekt - genauer: seine Instanzvariablen, "sein Zustand" -
müssen zu jedem Zeitpunkt gültige Werte enthalten !

// ==========================================

Objekte mit Vorbelegungswerten erzeugen:

Dazu gibt es spezielle Methoden:  Konstruktor(en)

"sie konstruieren das Objekt"

Unterschied zu "normalen" Methoden:

i) Name ist festgelegt: Name der Klasse
ii) KEIN RÜCKGABETYP

In der Regel hat eine Klasse mehrere Konstruktoren.

Es gibt eine Technik für das "Wiederverwenden" von Konstruktoren-Quellcode:

"C++ Chaining of constructors"  // Verketten von Konstruktoren

 This feature is called "delegating constructors"

// ==============================================

m_day = nullptr;

Das geht nicht:

Weil Variablen elementaren Datentyps KEINE Objekte sind.

nullptr ginge nur bei Zeigern.

Das geht auch nicht bei Java / C# -- wenngleich es hier 
Unterschiede gibt (Boxing, Unboxing).

(( std::optional ))

"Bei Strings geht das":   std::string ist eine Klasse.

// ==============================================

Copy - Paste Programmierung:

a) Bei Änderungen muss ich n-fach ändern

b) Im dem besagten Stück Quellcode wurde ein Fehler entdeckt:

   Der muss n-fach geändert werden.

   Copy - Paste kopiert auch Fehler :(


// ==========================================

inline:

Es erfolgt kein CALL (ein CALL kostet im Vergleich mehr Laufzeit)

Sondern es wird im Maschinencode der Code des Rumpfes eingesetzt.

An einem Beispiel setDay: 14 Opcodes werden "inline" abgesetzt

inline ist ein "Hint" / Hinweis an den Übersetzer:

Tue das; Der Übersetzer entscheidet eigenständig.

// ==========================================

Code-Generator

Optimizer

Release-Mode

inline:  Performance 

Anderes Thema:

Vererbung  // virtual methods

'virtual' bedeutet: INDIREKTER Methodenaufruf

Performance:  Profiling

== regular expression
== std::string concatenation

Meine Meinung: IMHO

== Lesbarkeit: Sehr wichtig

== std::vector

   std::map   (Inhalt liegt sortiert vor)

   std::unordered_map  (Inhalt liegt NICHT sortiert vor)

   Suchen : Muss man tun. Wenn häufiger gesicht wird: Container wichtig.

== Call-by-XXX : "Wie häufig übergebe ich eine Kopie (unabsichtlich !!!)" // '&'

== STL ist sehr effizient und auch performant, wenn man sie richtig einsetzt.

    -- pro STL: Denken in "Bausteinen" // Rumpf der beteiligten "Funktion"

    -- contra STL: Das eine oder andere kann man (Beispiel: geschachtelte Schleifen)
             bequemer // effizienter programmieren.
             Möglicherweise fehleranfälliger IMHO.


== Kryptisches C:   Nebeneffekt    if (a > b && c < d++)  Was ist wenn a nicht größer b ist ???

                                    Short Circuit Evaluation

// ==========================================

Wozu gibt es Referenzen in C++?

Pointer sind "ähnlich" und können alles.

a) Pointer können zu Fehlern führen:  zb bei der Pointer-Arithmetik (zb ++ip)
   
b) Um für den indirekten Zugriff eine einfachere Schreibweise zu haben !!!
   -----------------------------------------------------------------------

   Man hat den * (Dereferenzierung) weggelassen !!!


C:     ++ *ip;     // unter der Annahme, dass ip gültig ist

C++:   ++ri;       // unter Beachtung, dass ri per Definition immer gültig ist


Bemerkung: C ist in C++ enthalten - das war eine Entwurfsentscheidung bei der Definition von C++.

// ==========================================

Dynamische Objekte:

== Klassischen Weise:   int*

== Modernen Weise:      Smart Pointer (std::unique_ptr, ...)



// ==========================================


C#, Java: Sind konzeptionell EINFACHER 

new, delete nicht auf andere Art und Weise lösen kann:  GC

Warum hat C++ keine GC ???

Weil C++ in seiner Def. zu komplex ist.

JVM

// ==========================================


Parameterübergabe:

Prinzipiell: 

a) Value-based Languages

      C++: Per Default wird alles kopiert, per Wert weitergereicht
      Werte liegen am Stack

b) Reference-based Languages:

      C# , Java: Alles wird über eine Referenz erreicht (Ausnahme: elem. Datentypen)
      Alles liegt am Heap

      
In C++ können wir auch Parameter-Übergabe per Poiner / Referenz machen.


Besser : Call-by-Reference - (also keine C-Style Pointer).


Der Stack kann - im Gegensatz zu anderen Segmenten -
nur über ein Register angesprochen werden:

SP: Stack Pointer

Push:    ++ SP
Pop:     -- SP
Ret
Call

// ==========================================


// Überladen von Operatoren

Geht für nahezu alle Standard-C++-Operatoren.

Es sind nur Standard-C++-Operatoren erlaubt!

Und zu beachten ist:

Technisch wie das Erstellen einer Methoden / mit einem speziellen Namen.

Stelligkeit:  Es muss die Anzahl der Operanden identisch wie mit dem
vordefinierten Fall übereinstimmen.

Beispiel: == bedeutet 2 Operanden.

// ==========================================

Allgemeines // Design:

Date increment(const Date& other);   // 6.12 ==> 7.12

oder

void increment(Date& other);         // 6.12 ==> 7.12


Date increment(const Date& other)
{
    Date result;
    ....
    return result;
}


Soll das Ergebnis im Parameter oder über den Rückgabewert gebildet werden ?

a) GEHT BEIDES:

Mutable or Immutable

Veränderbar oder Unveränderbar

Fraction f1 (3, 7);
Fraction f2 (4, 9);

Fraction f3;

f3 = f1.add (f2);    // Wo landet offensichtlich das Ergbnis? In f3 !!! Unveränderbar

f1.sum (f2);         // Wo landet offensichtlich das Ergbnis? In f1 !!! Mutable / Veränderbar

oder

f1.add (f2, f3);     // Wo landet offensichtlich das Ergbnis? In f3 !!!   Nicht so schön

IMHO: Mir gefällt die erste Variante am besten.

// ==========================================


Übung: Klasse Fraction

oder alternativ:

Klasse Time:

https://github.com/pelocpp/cpp_general_examples/blob/master/Examples/Time/Resources/Readme.md

============================================================

Lösung:

https://github.com/pelocpp/cpp_general_examples/blob/master/Examples/Fraction/Resources/Readme.md

============================================================

Welche Lebensdauer bzgl. Objekten gibt es in C++:

== Lokale Variablen / Objekte ("wenn der Scope verlassen wird")
    Typischerweise Variablen von Methoden
    Werden am STACK_SEGMENT angelegt / abgeräumt (Stack-Pointer)
    Wer verwaltet den Stackzeiger?
    Einige Op-Codes: push, pop, call, ret
    Es wird ein STACK FRAME pro Unterprogramm Aufruf angelegt auf dem Stack
    ... und bei RET wird dieser wieder abgeräumt

== Globale Variablen
    Sind von überall erreichbar // problematisch bei der Fehlersuche
    Sind die gesamte Laufzeit vorhanden (wenn dieser Bereich groß)
    Werden in einem DATA_SEGMENT angelegt.

== Dynamische Objekte
    Liegen am Heap / Halde
    Intel: EX : EXTRA_SEGMENT
    Werden mit new allokiert ... und mit delete freigegeben.
    Die Daten stehen bei Gebrauch zur Verfügung ... und sind danach aber EXPLIZIT freizugeben.
    NO Garbage Collection.
    Algo:  Freispeicherverwaltung

-----------

== Code Segemt:
     Hier liegt der Maschinencode
     CODE_SEGMENT

============================================================

Dynamische Daten in Objekten:

== Werden im Kontruktor oder auch in Methodenaufrufen erzeugt

== Leben solange, wie das Objekt lebt

== MÜSSEN im Destruktor freigegeben werden !

Wer erzeugt den Destruktor Aufruf?

a) Globales Objekt:      der Compiler beim Verlassen von main
b) Lokales Objekt:       der Compiler beim Verlassen der Methode
c) Dynamisches Objekt:   der Anwender durch den Aufruf von delete !

============================================================

== 650:  ist freigegeben

============================================================

Beobachtung:

a) Für ALLE Objekte in C++ ist die Wertzuweisung implementiert !

b) Wie? Es werden ALLE Instanzvariablen umkopiert -  auch Zeiger !!!

c) Für Zeiger ist diese Vorgehensweise kritisch: 2 Objekte zeigen dann auf DENSELBEN Bereich im Heap.

d) Die beiden Destruktoren wollen DENSELBEN Zeiger mit delete freigeben: Der zweite delete stürzt ab !!!!

e) Diese Standard-Vorgehensweise nennt man "flache Kopie" // "shallow copy"

Konsequenz:

a) Für Klassen, die KEINE Zeiger enthalten, passt das ("flache Kopie")

b) Für Klassen, die Zeiger enthalten, MUSS der =-Operator implementiert werden !!!

c) Diesen Vorgang bezeichnet man als "Deep Copy" / "tiefe Kopie"

====================================================

Zweite Beobachtung:

a) Für ALLE Objekte in C++ ist ein Kopier-Konstruktor standardmäßig implementiert !

b) Wie? Es werden ALLE Instanzvariablen umkopiert -  auch Zeiger !!!

c) Für Zeiger ist diese Vorgehensweise kritisch: 2 Objekte zeigen dann auf DENSELBEN Bereich im Heap.

d) Die beiden Destruktoren wollen DENSELBEN Zeiger mit delete freigeben: Der zweite delete stürzt ab !!!!

e) Diese Standard-Vorgehensweise nennt man "flache Kopie" // "shallow copy"

Konsequenz:

a) Für Klassen, die KEINE Zeiger enthalten, passt das ("flache Kopie")

b) Für Klassen, die Zeiger enthalten, MUSS der Kopier-Konstruktor implementiert werden !!!

c) Diesen Vorgang bezeichnet man als "Deep Copy" / "tiefe Kopie"

====

Damit wären wir bei dem Schlagwort "BIG-THREE" angekommen:

== Destruktor
== Wertzuweisungs-Operator
== Kopier-Konstruktor

====

"Rule of ZERO": Ich muss NICHTS beachten :)

Wann kann ich mich auf die "Rule of ZERO" beziehen?

a) Wenn die Klasse keine Pointer (*) enthält

b) Wenn AUSSCHLIEßLICH Klassen aus der STL verwendet werden:

      - Container (std::vector)
      - Smart Pointer (z.B. std::unique_ptr)
      - Eben wenn keine klassischen Zeiger verwendet werden

// =================================================

What Is the Correct Way of Loop Through C++ Vector Using Index?

https://jdhao.github.io/2017/10/07/loop-forward-backward-with-cpp-vector/

// =================================================


Dienstag:

Dynamische Daten: yes

Big-Three: yes

static

Ternary operator

post und pre increment

shallow-copy und deep-copy: yes

namespaces / anonyme namespaces

NULL vs. nullptr: yes    

Undefined behaviour

Vererbung:  virtual / non virtual

Templates (nutzen und selbst programmieren, in einfacher Form)


============================================================
